1.某个函数是二进制安全的，怎么理解，举个例子

Binary-safe is a computer programming term mainly used in connection with string manipulating functions. A binary-safe function is essentially one that treats its input as a raw stream of data without any specific format. It should thus work with all 256 possible values that a character can take (assuming 8-bit characters).

二进制安全是一种主要用于字符串操作函数相关的计算机编程术语。一个二进制安全功能（函数），其本质上将操作输入作为原始的、无任何特殊格式意义的数据流。其在操作上应包含一个字符所能有的256种可能的值（假设为8位字符）。

例子：strlen 函数，对于\0的情况，不特殊处理，当成普通字符，Windows 下提供了一个文本转换标记（*'t'*）可以透明地将
   *\n* 转换为 *\r\n*。与此对应还可以使用 *'b'* 来强制使用二进制模式，这样就不会转换数据。要使用这些标记，要么用
  *'b'* 或者用 *'t'* 作为`mode` 参数的最后一个字符。

2.高并发下，缓存与数据库怎么保持数据同步，如页面浏览量，点赞量
将数据同步时间缩短，或者每100条新数据同步一次，将每次同步的数据量调低，来提升数据库和缓存的同步

3.订单事务中，一般用悲观锁保证安全，但会带来性能问题，如何以更好的办法解决
a. 使用乐观锁，会牺牲一下一些安全性，性能会提升，当数据冲突的时候，需要用户来决定如何去做
b. 调低事务隔离级别，例如调成未提交读，一个事务能读取到别的事务未提交的更新数据，很不安全，可能出现丢失更新、脏读、不可重复读、幻读；其他的可以是提交读，可重复读，序列化

乐观锁与悲观锁的一篇文章：http://cxis.me/2016/06/03/%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%E7%AE%80%E4%BB%8B/

4.redis会缓存很多的数据，但是数据容量有限，如何对过期时间设置，达到更好的效果？

5.一个对象，成员都是私有的，json_encode之后会有key value吗？怎么做呢？
不会有，需要将键值处理成可以读取到的
参阅：https://stackoverflow.com/questions/7005860/php-json-encode-class-private-members

6.接口做安全验证有几种方法？如何防止别人高频率一直重复调用？
安全验证方法：a.HTTPS 加密  b. 签名机制，即常见的token  c. 接口内容加密，一般用于内容完整性的验证，也是很重要的安全验证方式  d. oauth 2.0授权机制

DDOS的攻击方式有很多种，最基本的DOS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。CC攻击模拟多个用户(多少线程就是多少用户)不停的进行访问(访问那些需要大量数据操作，就是需要大量CPU时间的页面).这一点用一个一般的性能测试软件就可以做到大量模拟用户并发。

CC攻击的原理就是攻击者控制某些主机不停地发大量数据包给对方服务器造成服务器资源耗尽，一直到宕机崩溃。DDoS是主要针对IP的攻击，而CC攻击的主要是网页。CC攻击相对来说，攻击的危害不是毁灭性的，但是持续时间长;而DDoS攻击就是流量攻击，这种攻击的危害性较大，通过向目标服务器发送大量数据包，耗尽其带宽，需要足够的带宽和硬件防火墙才能防御。

7.写出你认为斐波那契数列的最优算法？不使用递归
斐波那契数列： 
1 1 2 3 5 8 13 21 34 55 …

概念： 
前两个值都为1，该数列从第三位开始，每一位都是当前位前两位的和 
规律公式为： 
Fn = F(n-1) + F(n+1) 
F：指当前这个数列 
n：指数列的下标
```php
非递归写法：
function fbnq($n){  //传入数列中数字的个数
    if($n <= 0){
        return 0;
    }
    $array[1] = $array[2] = 1; //设第一个值和第二个值为1
    for($i=3;$i<=$n;$i++){ //从第三个值开始
        $array[$i] = $array[$i-1] + $array[$i-2]; 
        //后面的值都是当前值的前一个值加上前两个值的和
    }
    return $array;
}

递归写法：
function fbnq($n){
    if($n <= 0) return 0;
    if($n == 1 || $n == 2) return 1;
    return fbnq($n - 1) + fbnq($n - 2);
}
```

8.讲述下里氏替换原则
Subtypes must be substitutable for their base types”（子类必须能够替换成它们的基类。）
里氏替换原则（Liskov Substitution Principle, LSP）的定义和主要思想如下：由于面向对象编程技术中的继承在具体的编程中过于简单，在许多系统的设计和编程实现中，我们并没有认真地、理性地思考应用系统中各个类之间的继承关系是否合适，派生类是否能正确地对其基类中的某些方法进行重写等问题。因此经常出现滥用继承或者错误地进行了继承等现象，给系统的后期维护带来了不少麻烦。这就需要我们有一个设计原则来遵循，它就是替换原则。

LSP指出：子类类型必须能够替换掉它们的父类型、并出现在父类能够出现的任何地方。它指导我们如何正确地进行继承和派生，并合理地重用代码。此原则认为，一个软件实体如果使用一个基类的话，那么一定适用于其子类，而且这根本不能察觉出基类对象和子类对象的区别。想一想，是不是和多态的概念比较像？

参阅：https://www.oudahe.com/p/51940/

9.如果你有一个任务需要使用内存，但是监控发现由于操作系统内存换进换出时不时内存会被换出到硬盘从而导致性能抖动，请问怎么解决？


10.请简单说一下基于继承特性在面向对象编程语言中是否是必要的？设计模式是否是必要的？有没有什么缺点？
有必要，对于对象中很多通用的部分，将其抽象出来，当成基类，而具体对象的操作继承基类，实现代码的复用和整洁。
设计模式并不是必要的，但是值得去学习的，设计模式可以帮助我们将应用组织成容易了解，容易维护，具有弹性的架构，建立可维护的OO系统，要诀在于随时想到系统以后可能需要的变化以及应付变化的原则。 设计模式让你和其他开发人员之间有共享的词汇，一旦懂这些词汇，和其他开发人员之间沟通这些观念就很容易，也会激起那些不懂的程序员想开始学习设计模式。
设计模式也可以帮助你提升思考架构的层次到模式层面，而不是停留在琐碎的对象上。面向对象原则，适用于所有的模式。当你无法找到适当的模式解决问题时，采用这些原则可以帮助你。
OO设计原则：
1、找出应用中可能需要变化之处，把它们独立出来， 不要和那些不需要变化的代码混在一起。这是我们的第一个设计原则
2、针对接口编程，而不是针对实现编程。
3、多用组合，少用继承。
关于优缺点可以参考：https://blog.csdn.net/wanglingxxx/article/details/52859815

11.是否知道除了传统oo之外的其他编程思想   
面向过程编程(C)
面向对象编程(C++，Java)
函数式编程(Python)
面向消息编程(Erlang)
面向过程与接口(Go)

如果用过go可以用interface这些举例，go中很多都是组合的概念

12.如果出于安全考虑，不允许使用root权限运行你的这个任务会怎样？有没有办法解决？


13.假定没有市交委这类组织，某城市2000万人口，如何统计出租车数量
大概估算的话技术含量不高，典型的market sizing问题，根据常识和基础数据推倒即可，但是看场景，如果需要进一步可以考虑HugePages之类的办法，mysql、hadoop中用HugePages也是有原因的，当然HugePages也不是万能的，

一般能说出mlock家族的办法都给过了，说出HugePages属于优秀了。顺便指出HugePages和mlock家族的优缺点的可以说是很有经验了

14.缓存这块我可以问如果某天活动流量过大缓存挂了，然后大量请求打到db造成db也挂了。请问怎么才能让系统活过来？redis aof有自动恢复，这个有什么优缺点？

雪崩情况下，用nginx直接返回空，app就不再尝试了，先想办法恢复线上业务，分流和熔断限流是一方面的答案，另一方面如果重新设计的话可以考虑用带持久化cache中间件，如果不重新设计临时发版解决可以考虑代码上对缓存重建加锁，可以建立二级缓存，但是多级缓存一致性也是个大问题，多核缓存一致性还有MESI协议，但是分布式则不然。问题会更加复杂的

以上主要是缓存重建的问题，业界有很多解决方案。其实还有基于paxos、zk的分布式锁解决缓存重建和一致性的办法，然后用kafka做数据总线，既然应用了pasox算法的话，应该就是针对大流量的场景采取分布式系统应对分流吧

aof 优缺点是：需要重新执行一遍指令，就是慢，但稳健，解决aof可以考虑基于mmap系统调用实现呐，而且这样做的好处还可以减少内核态fd拷贝次数epoll就是这么干的

答案多数是个人整理，有错误请指正，邮箱：limbo0720@outlook.com